# N皇后

使用回溯(本质是递归)的方法解这个题目.  

- 通过一个一维数组v表示每个queen的位置,
`(i,v[i])` 第i行，`v[i]` 列出现一个queen。
N个Queen，必定是每行一个，所以可用一维数组表示位置。  

- 递归方法：`v[i]` 分别赋值0 ... N-1,
如果前i行不会发生冲突，就试探第i+1行.直到每一行都试探完。

- 前行是否冲突的判断：`v[i]` 不与 `v[0...i-1]` 相等，
`j+v[j]` 【0 <= j < i 】 不与 `i+v[i]` 相等 【斜率为-1的方向判断】，
`j-v[j]` 【0 <= j < i 】 不与 `i-v[i]` 相等 【斜率为1的方向判断】.
只有i-1行没有冲突才会进行i行的判断，所以只需一遍判断。

- 上下文恢复:虽然使用的一维数组没有拷贝上下文，但是每一次检测的都是
前面i行,所以不需要恢复上下文状态。

# 547. 朋友圈

类似图的遍历,使用dfs的方法

- 使用visited一维数组表示是否遍历过，N名学生对应长度为N的一维数组
- 遍历到第i名学生时，将visited[i]置为true
- 寻找i的所有朋友，对没有访问过的朋友进行遍历
- 最外层使用一个for循环，遍历N名学生，遇到没有访问的学生计数加1，表示朋友圈数
